总结

1.如何处理大量并发请求

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    const fetchData = () => {
    fetch('/api').then(res=>{
        console.log(res);
    })
}
for(let i = 0;i<100;i++){
    fetchData();
}

</script>
</html>
```

```shell
// 启动
live-server --proxy=/api:http://127.0.0.1:3000
```



```javascript
const http = require('http');

const server = http.createServer((req,res)=>{
    res.writeHead(200,{
        'Content-Type': 'text/plain',
        'Access-Control-Allow-Origin': '*' 
    })
    setTimeout(() => {
        res.end('hello world');
    }, Math.random()*1000);
})
server.listen(3000);

```

方法1 使用await进行串行控制

改造请求代码

```javascript
const fetchData = async () => {
        await fetch('/api').then(res => {
            console.log(res);
        })
    }
let send = async function () {
    for (let i = 0; i < 100; i++) {
        await fetchData();
    }
}
send();
```

缺点：请求效率低

方法2 考虑chrome默认允许最多同时开启6条TCP链接，所以将请求分成5个一组。

改造代码

```javascript
let send = async function () {
        for (let i = 0; i < 100; i++) {
            const arr = [
                 fetchData(),
                 fetchData(),
                 fetchData(),
                 fetchData(),
                 fetchData(),
            ]
            await Promise.all(arr)
            i = i + 5;
        }

    }
```

缺点：all的局限性，如果请求中存在一个速度较慢，会影响一组请求的返回速度。

方法3 使用p-limit进行请求并发

```typescript
import PLimit from 'p-limit';
const pLimt = PLimit(5);
const execList: any[] = [];
async function fetchData() {
    await axios.get('/textApi').then(res => {
        return res;
    })
}
async function send(){
    for(let i = 0;i<100;i++){
        execList.push(pLimt(fetchData));
    }
    await Promise.all(execList);
}
```

